<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C++内存分配器 | Hexo</title><meta name="author" content="Zexin Wang"><meta name="copyright" content="Zexin Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++内存分配器"><meta name="application-name" content="C++内存分配器"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++内存分配器"><meta property="og:url" content="http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="1. SGI STL 空间配置器的主要职责是为对象分配和释放内存。 原地 new 函数 在已分配内存的指针中重新构造新对象 12&amp;#x2F;&amp;#x2F; ptr1 是一个以及分配内存的指针Myclass* ptr2 &amp;#x3D; (Type*)new (ptr1) TypeName; 1.1. 一级空间配置器 处理大于某一个阈值"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Zexin Wang"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1. SGI STL 空间配置器的主要职责是为对象分配和释放内存。 原地 new 函数 在已分配内存的指针中重新构造新对象 12&amp;#x2F;&amp;#x2F; ptr1 是一个以及分配内存的指针Myclass* ptr2 &amp;#x3D; (Type*)new (ptr1) TypeName; 1.1. 一级空间配置器 处理大于某一个阈值"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Zexin Wang","link":"链接: ","source":"来源: Hexo","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hexo',
  title: 'C++内存分配器',
  postAI: '',
  pageFillDescription: '1. SGI STL, 1.1. 一级空间配置器, 1.2. 二级空间配置器, 2. tcmalloc, 2.1. 前端, 2.1.1. Per-thread cache, 2.1.2. Per-CPU cache, 2.2. 中端, 2.2.1. Transfer Cache, 2.2.2. Central Free List, 2.3. 后端, 2.3.1. Legacy pageheap, 2.3.2. hugepage aware pageheap, 3. ptmalloc, 3.1. 内存分配, 3.2. 内存回收空间配置器的主要职责是为对象分配和释放内存原地函数在已分配内存的指针中重新构造新对象是一个以及分配内存的指针一级空间配置器处理大于某一个阈值通常为字节的大块内存分配分配内存的和将直接调用和针对内存不足无法分配内存空间的情况将调用函数处理分配内存申请失败调用方法模板特化函数指针指向内存分配失败处理函数死循环直到分配好内存没有设置失败处理函数则直接抛出异常重新分配内存代表旧的内存但是此处并没有使用参数模板特化不断释放内存再不断配置内存直到分配至合适的大小配置内存二级空间配置器当申请的空间小于或等于时则以内存池的方式进行管理的二级配置器会主动将任何较小的区块的内存需求量调整至的倍数申请的空间调整至申请申请的空间调整至申当申请内存或释放内存时二级配置器将会维护其中的链表第二步中如果当前位置没有分配区块需要先申请个区块然后前个区块串成链表剩下的个区块备用当作内存池其实在申请内存的时候需要先判断内存池中是否有足够多的容量如果足够的话就先分配内存池中的容量如果容量不够则重新申请新的空间也就是上一段话描述的那样目的防止小块内存频繁的分配释放造成大量内部碎片主要由三部分组成前端缓存是的形式如果特定大小的缓存用完了则向终端请求一批内存以重新填充缓存如果中端内存耗尽或者请求的内存大小超过前端缓存可处理的最大内存大小则会向后端发出请求以满足大容量分配或重新填充中端的缓存按照字节对齐被分配到个对应的中也就是不同大小的对象集链表中由前端分配否则后端分配如果前端没有剩余内存且传输缓存有剩余空间将传输缓存中的内存分配给前端对应大小的链表中再分配给对象如果前端没有剩余内存且传输缓存没有剩余空间从中提取内存块再通过传输缓存分配给前端最后分配给对象直接从后台分配较大对象大小的分配请求向上舍入为页面大小前端每个线程对应一个缓存适用于线程数量较多锁竞争较为严重的场景系统中的每个逻辑都有自己的缓存来分配内存适用于线程数量较少每个线程内存使用量相对固定的场景中端中端负责向前端提供内存并向后端返回内存中端由和组成每个都有一个传输缓存和一个中央空闲列表这些缓存都受到互斥锁的保护因此访问它们会产生序列化成本当前端请求内存或返回内存时它会访问传输缓存传输缓存保存着一个指向空闲内存的指针数组可以快速将对象移入该数组或代表前端从该数组中获取对象传输缓存的名称来源于一个分配的内存是另一个或线程释放的内存传输缓存允许内存在两个不同的或线程之间快速流动如果转移缓存无法满足内存请求或没有足够空间容纳返回的对象它将访问中央空闲列表中央空闲列表以为单位管理内存每个由若干个页面组成从中提取对象来满足对一个或多个对象的请求直到满足请求为止如果中没有足够的可用对象则会向后端请求更多的当对象返回到中央空闲列表时每个对象都会被映射到其所属的然后被释放到该中如果某个中的所有对象都被返回则该会被返回到后端后端管理大块未使用的内存当没有合适大小的内存来满足分配请求时它负责从操作系统获取内存它负责将不需要的内存返还给操作系统类似于但是连接的是当时第个节点由个组成第个节点是长度大于页的空闲运行列表我们可以通过查找第个空闲列表来满足个页面的分配如果那个空闲列表是空的我们就查找下一个空闲列表依此类推最后如果需要当我们查找到最后一个空闲列表依然失败时我们将通过系统的获取内存如果长度大于的页面满足了对个页面的分配则结点剩余的部分将被重新插入到适当的空闲列表中当向页面堆返回一定范围的页面时将检查相邻的页面以确定它们现在是否形成了一个连续的区域如果是这样则将这些页面连接起来并放置到适当的空闲列表中减少内部碎片减小分页堆大小块对应的格式如果是连续的内存字段会变成前一块的数据部分中主要有每个中都使用类似于结构来管理对象但是中使用的是单链表其余的是双链表内存分配获取分配区的锁防止多线程冲突计算出实际需要分配的内存的实际大小判断的大小如果小于则尝试去上取适合的如果有则分配结束否则下一步判断大小是否小于如果是则从上去查找如果有合适的则分配结束否则下一步首先会遍历中的将相邻的进行合并并链接到中然后遍历如果上只有一个并且大于待分配的则进行切割并且剩余的继续扔回如果上有大小和待分配相等的则返回并从删除如果中的某一大小属于的范围则放入的头部如果中的某一大小属于的范围则找到合适的位置放入若未分配成功转入下一步从中查找找到合适的之后然后进行切割一部分分配给用户剩下的放入中如果搜索和都没有找到合适的那么就需要操作来进行分配了当大小比用户所请求大小还大的时候会分为两个部分用户请求大小和剩余大小其中成为新的当大小小于用户所请求的大小时就通过或系统调用来扩容到了这一步说明也不能满足分配要求所以于是就有了两个选择如果是主分配区调用增加大小如果是非主分配区调用来分配一个新的增加大小或者使用来直接分配在这里需要依靠的大小来决定到底使用哪种方法判断所需分配的大小是否大于等于分配阈值如果是的话则转下一步调用分配否则跳到第步增加的大小使用系统调用为程序的内存空间映射一块大小的空间然后将内存指针返回给用户判断是否为第一次调用若是主分配区则需要进行一次初始化工作分配一块大小为大小的空间作为初始的若已经初始化过了主分配区则调用增加空间主分配区则在中切割出一个使之满足分配需求并将内存指针返回给用户内存回收获取分配区的锁保证线程安全如果的是空指针则返回什么都不做判断当前是否是映射区域映射的内存如果是则直接释放这块内存前面的已使用的数据结构中我们可以看到有来标识是否是映射的内存判断是否与相邻如果相邻则直接和合并和相邻相当于和分配区中的空闲内存块相邻转到步骤如果的大小大于则放入并且检查是否有合并有合并情况并且和相邻则转到步骤没有合并情况则如果的大小小于则直接放入并没有改变的状态没有合并情况则有合并情况转到步骤在如果当前的下一个也是空闲的则将这两个合并放入上面合并后的大小如果大于会触发进行的合并操作中的将被遍历并与相邻的空闲进行合并合并后的会被放到中会变为空合并后的和相邻则会合并到中转到步骤判断的大小是否大于收缩阈值默认为如果是的话对于主分配区则会试图归还中的一部分给操作系统结束',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-01 18:56:40',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Hexo</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">七月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">C++内存分配器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-01-01T10:54:45.000Z" title="发表于 2025-01-01 18:54:45">2025-01-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-01-01T10:56:40.639Z" title="更新于 2025-01-01 18:56:40">2025-01-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"><header><h1 id="CrawlerTitle" itemprop="name headline">C++内存分配器</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Zexin Wang</span><time itemprop="dateCreated datePublished" datetime="2025-01-01T10:54:45.000Z" title="发表于 2025-01-01 18:54:45">2025-01-01</time><time itemprop="dateCreated datePublished" datetime="2025-01-01T10:56:40.639Z" title="更新于 2025-01-01 18:56:40">2025-01-01</time></header><h2 id="1-SGI-STL">1. SGI STL</h2>
<p>空间配置器的主要职责是为对象分配和释放内存。</p>
<p><strong>原地 new 函数</strong></p>
<p>在已分配内存的指针中重新构造新对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr1 是一个以及分配内存的指针</span></span><br><span class="line">Myclass* ptr2 = (Type*)<span class="keyword">new</span> (ptr1) TypeName;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-一级空间配置器">1.1. 一级空间配置器</h3>
<p>处理大于某一个阈值(通常为 128 字节)的大块内存分配</p>
<p>分配内存的 allocate() 和 deallocate() 将直接调用 malloc() 和 free()，针对内存不足无法分配内存空间的情况将调用 set_new_handler() 函数处理。</p>
<ol>
<li>分配内存</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == result) result = oom_malloc(n); <span class="comment">// 申请失败，调用 set_new_handler() 方法</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> inst&gt;    <span class="comment">// 模板特化</span></span><br><span class="line"><span class="keyword">void</span>* _malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class="keyword">siez_t</span> n)&#123;</span><br><span class="line">    <span class="keyword">void</span> (* my_malloc_handler)();    <span class="comment">//函数指针，指向内存分配失败处理函数</span></span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;  <span class="comment">// 死循环，直到分配好内存</span></span><br><span class="line">        my_malloc_handler = _malloc_alloc_oom_handler;</span><br><span class="line">        <span class="comment">// 没有设置失败处理函数，则直接抛出std::bad_alloc异常</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == my_malloc_handler)&#123; _THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*my_malloc_handler)();</span><br><span class="line">        result  = <span class="built_in">realloc</span>(p,n);</span><br><span class="line">        <span class="keyword">if</span>(result) <span class="keyword">return</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>重新分配内存</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallpcate</span><span class="params">(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>,<span class="keyword">size_t</span> new_sz)</span></span>&#123;</span><br><span class="line">    <span class="comment">//old_sz代表旧的内存，但是此处并没有使用参数old_sz</span></span><br><span class="line">    <span class="keyword">void</span>* result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">templae&lt;<span class="keyword">int</span> inst&gt;    <span class="comment">//模板特化</span></span><br><span class="line"><span class="keyword">void</span>* _malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span>* p, <span class="keyword">size_t</span> n)&#123;</span><br><span class="line">    <span class="keyword">void</span> (* my_malloc_handler) ();</span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;    <span class="comment">//不断释放内存，再不断配置内存，直到分配至合适的大小</span></span><br><span class="line">        my_malloc_handler = _malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == my_malloc_handler) &#123; _THROW_BAD_ALLOC; &#125;</span><br><span class="line">        (*my_malloc_hanlder) ();</span><br><span class="line">        result = <span class="built_in">realloc</span>(p,n);    <span class="comment">//配置内存</span></span><br><span class="line">        <span class="keyword">if</span>(result) <span class="keyword">return</span>(result);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-二级空间配置器">1.2. 二级空间配置器</h3>
<p>当申请的空间小于或等于 128 bytes 时，则以内存池的方式进行管理。SGI的二级配置器会主动将任何较小的区块的内存需求量调整至 8 的倍数(申请 1 bytes 的空间，调整至申请 8 bytes，申请 10 bytes 的空间调整至申 16 bytes)，当申请内存或释放内存时，二级配置器将会维护其中的 free-listes 链表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5C1733993313310-5021ec28-7e34-46f6-9548-bc95955030d9.png" alt="img"></p>
<p>第二步中，如果当前位置没有分配区块，需要先申请 2*20 个区块，然后前 20 个区块串成链表。剩下的 20 个区块备用，当作内存池。</p>
<p>其实，在申请内存的时候，需要先判断内存池中是否有足够多的容量，如果足够的话就先分配内存池中的容量。如果容量不够，则重新申请新的空间，也就是上一段话描述的那样。</p>
<p>目的：防止小块内存频繁的分配，释放，造成大量内部碎片。</p>
<h2 id="2-tcmalloc">2. tcmalloc</h2>
<p>主要由三部分组成：</p>
<ul>
<li>front-end</li>
<li>middle-end</li>
<li>back-end</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5Ctcmalloc_internals.png" alt="img"></p>
<p>前端缓存是 free list 的形式，如果特定大小的缓存用完了，则向终端请求一批内存，以重新填充缓存。</p>
<p>如果中端内存耗尽，或者请求的内存大小超过前端缓存可处理的最大内存大小，则会向后端发出请求，以满足大容量分配，或重新填充中端的缓存。</p>
<p>tcmalloc 按照 16 字节对齐，small objects 被分配到 60-80 个对应的 size-class 中，也就是不同大小的对象集链表中。</p>
<ul>
<li>size &lt;= kMaxSize：由前端分配，否则，后端分配。如果前端没有剩余内存且传输缓存有剩余空间，将传输缓存中的内存分配给前端对应大小的链表中，再分配给对象。如果前端没有剩余内存且传输缓存没有剩余空间，从 Central free list 中提取内存块，再通过传输缓存分配给前端，最后分配给对象。</li>
<li>size &gt; kMaxSize：直接从后台分配。较大对象大小的分配请求向上舍入为TCMalloc页面大小。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5C1734591626225-32fc1025-a8ae-470d-a7c8-9f02987b4a03.png" alt="img"></p>
<h3 id="2-1-前端">2.1. 前端</h3>
<h4 id="2-1-1-Per-thread-cache">2.1.1. Per-thread cache</h4>
<p>每个线程对应一个缓存。适用于线程数量较多、锁竞争较为严重的场景。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5Cper-thread-structure.png" alt="img"></p>
<h4 id="2-1-2-Per-CPU-cache">2.1.2. Per-CPU cache</h4>
<p>系统中的每个逻辑 CPU 都有自己的缓存来分配内存。适用于线程数量较少、每个线程内存使用量相对固定的场景。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5Cper-cpu-cache-internals.png" alt="img"></p>
<h3 id="2-2-中端">2.2. 中端</h3>
<p>中端负责向前端提供内存，并向后端返回内存。中端由 Transfer Cache 和 Central free list 组成。（每个 size-class 都有一个传输缓存和一个中央空闲列表）这些缓存都受到互斥锁的保护，因此访问它们会产生序列化成本。</p>
<h4 id="2-2-1-Transfer-Cache">2.2.1. Transfer Cache</h4>
<p>当前端请求内存或返回内存时，它会访问传输缓存。传输缓存保存着一个指向空闲内存的指针数组，可以快速将对象移入该数组，或代表前端从该数组中获取对象。</p>
<p>传输缓存的名称来源于一个CPU分配的内存是另一个CPU（或线程）释放的内存。传输缓存允许内存在两个不同的CPU（或线程）之间快速流动。</p>
<p>如果转移缓存无法满足内存请求，或没有足够空间容纳返回的对象，它将访问中央空闲列表。</p>
<h4 id="2-2-2-Central-Free-List">2.2.2. Central Free List</h4>
<p>中央空闲列表以 span 为单位管理内存，每个 span 由若干个页面组成。</p>
<p>从 spans 中提取对象来满足对一个或多个对象的请求，直到满足请求为止。如果 spans 中没有足够的可用对象，则会向后端请求更多的 spans。</p>
<p>当对象返回到中央空闲列表时，每个对象都会被映射到其所属的 span，然后被释放到该 span 中。如果某个 span 中的所有对象都被返回，则该 span 会被返回到后端。</p>
<h3 id="2-3-后端">2.3. 后端</h3>
<ul>
<li>管理大块未使用的内存。</li>
<li>当没有合适大小的内存来满足分配请求时，它负责从操作系统获取内存。</li>
<li>它负责将不需要的内存返还给操作系统。</li>
</ul>
<h4 id="2-3-1-Legacy-pageheap">2.3.1. Legacy pageheap</h4>
<p>类似于 free lists，但是连接的是 page。当 k &lt; 256 时，第 k 个节点由 k 个 page 组成。第 256 个节点是长度大于 256 页的空闲运行列表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5Clegacy_pageheap.png" alt="img"></p>
<p>我们可以通过查找第 k 个空闲列表来满足 k 个页面的分配。如果那个空闲列表是空的，我们就查找下一个空闲列表，依此类推。最后，如果需要，当我们查找到最后一个空闲列表依然失败时，我们将通过系统的 mmap 获取内存。</p>
<p>如果长度大于 k 的页面满足了对 k 个页面的分配，则结点剩余的部分将被重新插入到适当的空闲列表中。</p>
<p>当向页面堆返回一定范围的页面时，将检查相邻的页面，以确定它们现在是否形成了一个连续的区域，如果是这样，则将这些页面连接起来并放置到适当的空闲列表中。（减少内部碎片）</p>
<h4 id="2-3-2-hugepage-aware-pageheap">2.3.2. hugepage aware pageheap</h4>
<p>减小分页堆大小</p>
<h2 id="3-ptmalloc">3. ptmalloc</h2>
<p>chunk 块对应的格式，如果是连续的内存， prev_size 字段会变成前一块的数据部分。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5C1734658184270-663a0b9e-6e1c-494f-8f74-72bb153d1610.png" alt="img"></p>
<p>arena 中主要有 fastbin，unsorted bin，small bin，large bin，top。每个 bin 中都使用类似于 free list 结构来管理对象，但是 fastbin 中使用的是单链表，其余的是双链表（expect top）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%5C1734658317637-16a82bff-5d04-4d88-8441-e9b6f03a92ed.png" alt="img"></p>
<h3 id="3-1-内存分配">3.1. 内存分配</h3>
<ol>
<li>获取分配区的锁，防止多线程冲突。</li>
<li>计算出实际需要分配的内存的 chunk 实际大小。</li>
<li>判断 chunk 的大小，如果小于 max_fast（128Ｂ），则尝试去 fast bins 上取适合的 chunk，如果有则分配结束。否则，下一步；</li>
<li>判断 chunk 大小是否小于 1024B，如果是，则从 small bins 上去查找 chunk，如果有合适的，则分配结束。否则下一步；</li>
<li>ptmalloc 首先会遍历 fast bins 中的 chunk，将相邻的 chunk 进行合并，并链接到 unsorted bin 中然后遍历 unsorted bins。如果 unsorted bins 上只有一个 chunk 并且大于待分配的 chunk，则进行切割，并且剩余的 chunk 继续扔回 unsorted bins；如果 unsorted bins 上有大小和待分配 chunk 相等的，则返回，并从 unsorted bins 删除；如果 unsorted bins 中的某一 chunk 大小属于 small bins 的范围，则放入 small bins 的头部；如果 unsorted bins 中的某一 chunk 大小 属于 large bins 的范围，则找到合适的位置放入。若未分配成功，转入下一步；</li>
<li>从 large bins 中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入 unsorted bin 中。</li>
<li>如果搜索 fast bins 和 bins 都没有找到合适的 chunk，那么就需要操作 top chunk 来进行分配了<br>
当 top chunk 大小比用户所请求大小还大的时候，top chunk 会分为两个部分：User chunk（用户请求大小）和 Remainder chunk（剩余大小）。其中 Remainder chunk 成为新的 top chunk。当 top chunk 大小小于用户所请求的大小时，top chunk 就通过 sbrk（main arena）或 mmap（thread arena）系统调用来扩容。</li>
<li>到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap() 来直接分配。在这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值（128 kb），如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。</li>
<li>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初始化过了，主分配区则调用 sbrk() 增加 heap 空间，主分配区则在 top chunk 中切割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
<h3 id="3-2-内存回收">3.2. 内存回收</h3>
<ol>
<li>获取分配区的锁，保证线程安全。</li>
<li>如果 free 的是空指针，则返回，什么都不做。</li>
<li>判断当前 chunk 是否是 mmap 映射区域映射的内存，如果是，则直接 munmap() 释放这块内存。前面的已使用 chunk 的数据结构中，我们可以看到有 M 来标识是否是 mmap 映射的内存。</li>
<li>判断 chunk 是否与 top chunk 相邻，如果相邻，则直接和 top chunk 合并（和 top chunk 相邻相当于和分配区中的空闲内存块相邻）。转到步骤8</li>
<li>如果 chunk 的大小大于 max_fast，则放入 unsorted bin，并且检查是否有合并，有合并情况并且和 top chunk 相邻，则转到步骤8；没有合并情况则 free。</li>
<li>如果 chunk 的大小小于 max_fast，则直接放入 fast bin，fast bin 并没有改变 chunk 的状态。没有合并情况，则 free；有合并情况，转到步骤7</li>
<li>在 fast bin，如果当前 chunk 的下一个 chunk 也是空闲的，则将这两个 chunk 合并，放入 unsorted bin 上面。合并后的大小如果大于 128B，会触发进行 fast bins 的合并操作，fast bins 中的 chunk 将被遍历，并与相邻的空闲 chunk 进行合并，合并后的 chunk 会被放到 unsorted bin 中， fast bin 会变为空。合并后的 chunk 和 top chunk 相邻，则会合并到 top chunk 中。转到步骤8</li>
<li>判断top chunk的大小是否大于 mmap 收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还 top chunk 中的一部分给操作系统。free 结束。</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Zexin Wang</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/')">C++内存分配器</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++内存分配器&amp;url=http://example.com/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/01/01/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智能指针源码剖析</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SGI-STL"><span class="toc-number">1.</span> <span class="toc-text">1. SGI STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%80%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 一级空间配置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 二级空间配置器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-tcmalloc"><span class="toc-number">2.</span> <span class="toc-text">2. tcmalloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%89%8D%E7%AB%AF"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 前端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Per-thread-cache"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. Per-thread cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Per-CPU-cache"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. Per-CPU cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%AD%E7%AB%AF"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 中端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Transfer-Cache"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. Transfer Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Central-Free-List"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. Central Free List</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%90%8E%E7%AB%AF"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 后端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Legacy-pageheap"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. Legacy pageheap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-hugepage-aware-pageheap"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. hugepage aware pageheap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ptmalloc"><span class="toc-number">3.</span> <span class="toc-text">3. ptmalloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 内存回收</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/" title="C++内存分配器">C++内存分配器</a><time datetime="2025-01-01T10:54:45.000Z" title="发表于 2025-01-01 18:54:45">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="智能指针源码剖析">智能指针源码剖析</a><time datetime="2025-01-01T10:49:01.000Z" title="发表于 2025-01-01 18:49:01">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/30/SGX%E4%B8%AD%E4%BD%BF%E7%94%A8GMP-PBC/" title="SGX中使用GMP&amp;PBC">SGX中使用GMP&amp;PBC</a><time datetime="2024-11-30T10:40:43.000Z" title="发表于 2024-11-30 18:40:43">2024-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/30/Intel-SGX-for-Ubuntu/" title="Intel SGX for Ubuntu">Intel SGX for Ubuntu</a><time datetime="2024-11-30T02:58:09.000Z" title="发表于 2024-11-30 10:58:09">2024-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/24/Hot100-Day1/" title="Hot100 Day1">Hot100 Day1</a><time datetime="2024-09-24T15:10:15.000Z" title="发表于 2024-09-24 23:10:15">2024-09-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Zexin Wang" target="_blank">Zexin Wang</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Zexin Wang 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>